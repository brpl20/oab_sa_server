# Cleanup driver manager
    try:
        driver_manager.cleanup()
    except:
        pass
    
    print("üö™ Saindo...")
    sys.exit(0)

# Register the signal handler
signal.signal(signal.SIGINT, signal_handler)

def clean_state(state):
    """Clean state field to keep only valid Brazilian state codes (2 letters)"""
    if not state:
        return state
    
    # Remove any non-alphabetic characters and convert to uppercase
    cleaned = re.sub(r'[^A-Za-z]', '', str(state)).upper()
    
    # Keep only first 2 characters if longer
    if len(cleaned) > 2:
        cleaned = cleaned[:2]
    
    # Validate it's a valid Brazilian state code
    valid_states = {
        'AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 
        'MA', 'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 
        'RJ', 'RN', 'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO'
    }
    
    if cleaned in valid_states:
        return cleaned
    else:
        print(f"‚ö†Ô∏è Estado inv√°lido encontrado: '{state}' -> '{cleaned}' (n√£o √© um estado brasileiro v√°lido)")
        return cleaned  # Return anyway, let the API handle validation

def should_process_record(record):
    """Determine if a record should be processed based on the criteria"""
    # Scenario 1: Record doesn't have "processed": true
    if not record.get('processed', False):
        return True, "n√£o processado"
    
    # Scenario 2: Record is processed but has empty society arrays
    society_basic = record.get('society_basic_details', [])
    society_complete = record.get('society_complete_details', [])
    
    # If has_society is True but either array is empty, reprocess
    if record.get('has_society', False):
        if not society_basic or not society_complete:
            return True, "sociedades incompletas"
    
    # If has_society is None or False, check if it should have been True
    # (This handles cases where the initial processing failed to detect societies)
    if record.get('has_society') is None:
        return True, "status de sociedade n√£o determinado"
    
    # Record is complete and doesn't need reprocessing
    return False, "completo"

# Proxy utility functions (integrated)
def get_requests_session_with_proxy():
    """Returns a requests session configured with the rotating proxy"""
    try:
        session = requests.Session()
        session.proxies.update(PROXY_CONFIG)
        # Add timeout and headers for better reliability
        session.timeout = 30
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
        })
        return session
    except Exception as e:
        logger.error(f"Error creating session: {str(e)}")
        return None

def get_current_ip():
    """Get the current IP address being used by the proxy (silent)"""
    try:
        session = get_requests_session_with_proxy()
        if session is None:
            return None
        response = session.get('https://ip.decodo.com/json', timeout=10)
        if response.status_code == 200:
            return response.json()
    except:
        pass
    return None

def verify_proxy_connection():
    """Verify that the proxy connection is working properly (silent)"""
    ip_data = get_current_ip()
    return ip_data is not None

def save_ip_log(ip_data, filename="proxy_ip_log.json"):
    """Save IP data to S3 and local backup"""
    try:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = {
            "timestamp": timestamp,
            "ip_data": ip_data
        }
        
        # Try to append to existing log or create new one
        try:
            # For S3, we'll create a new timestamped entry
            s3_key = f"logs/proxy_ip_log_{time.strftime('%Y%m%d')}.jsonl"
            log_line = json.dumps(log_entry) + "\n"
            
            # Upload to S3 (this will overwrite, so for logs we might want a different approach)
            upload_to_s3(log_line, s3_key, 'text/plain')
        except:
            pass
            
        # Local backup
        try:
            with open(filename, 'a') as f:
                f.write(json.dumps(log_entry) + "\n")
        except:
            pass
    except:
        pass

def make_request_with_retry(method, url, max_retries=4, retry_delay=2, **kwargs):
    """Make HTTP request with retry logic for None responses and other errors"""
    for attempt in range(max_retries):
        try:
            session = get_requests_session_with_proxy()
            if session is None:
                print(f"        ‚ö†Ô∏è Tentativa {attempt + 1}: Falha ao criar sess√£o")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                else:
                    raise Exception("Failed to create session after all retries")
            
            # Make the request
            if method.upper() == 'POST':
                response = session.post(url, **kwargs)
            elif method.upper() == 'GET':
                response = session.get(url, **kwargs)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            # Check if response is None
            if response is None:
                print(f"        ‚ö†Ô∏è Tentativa {attempt + 1}: Resposta None recebida")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                else:
                    raise Exception("Response is None after all retries")
            
            # Check status code
            response.raise_for_status()
            return response
            
        except Exception as e:
            error_msg = str(e)
            print(f"        ‚ö†Ô∏è Tentativa {attempt + 1} falhou: {error_msg}")
            
            # If it's the last attempt, raise the error
            if attempt >= max_retries - 1:
                raise Exception(f"Request failed after {max_retries} attempts: {error_msg}")
            
            # Wait before retry
            print(f"        ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
            time.sleep(retry_delay)
    
    # This should never be reached, but just in case
    raise Exception(f"Request failed after {max_retries} attempts")

def extract_modal_data(modal_html):
    """Extract all data from the modal content"""
    soup = BeautifulSoup(modal_html, 'html.parser')

    result = {
        'firm_name': soup.select_one('.modal-title b').text.strip() if soup.select_one('.modal-title b') else None,
        'inscricao': None,
        'estado': None,
        'situacao': soup.select_one('.label').text.strip() if soup.select_one('.label') else None,
        'endereco': None,
        'telefones': None,
        'socios': []
    }

    # Extract inscricao
    inscricao_elem = soup.find('b', string=lambda text: text and 'Inscri√ß√£o:' in text)
    if inscricao_elem:
        result['inscricao'] = inscricao_elem.parent.get_text(strip=True).replace('Inscri√ß√£o:', '').strip()

    # Extract estado
    estado_elem = soup.find('b', string=lambda text: text and 'Estado:' in text)
    if estado_elem:
        result['estado'] = estado_elem.parent.get_text(strip=True).replace('Estado:', '').strip()

    # Extract endereco
    endereco_elem = soup.find('b', string=lambda text: text and 'Endere√ßo:' in text)
    if endereco_elem:
        result['endereco'] = endereco_elem.parent.get_text(strip=True).replace('Endere√ßo:', '').strip()

    # Extract telefones
    telefones_elem = soup.find('b', string=lambda text: text and 'Telefones:' in text)
    if telefones_elem:
        result['telefones'] = telefones_elem.parent.get_text(strip=True).replace('Telefones:', '').strip()

    # Extract partners data
    for row in soup.select('.socContainer tr'):
        cols = row.find_all('td')
        if len(cols) >= 4:
            result['socios'].append({
                'numero': cols[0].get_text(strip=True),
                'nome': cols[1].get_text(strip=True),
                'nome_social': cols[2].get_text(strip=True),
                'tipo': cols[3].get_text(strip=True),
                'cna_link': row.get('data-cnalink', '')
            })

    return result

async def process_sociedade_async(sociedade, state, insc, lawyer_name, executor):
    """Process a single sociedade asynchronously with retry logic"""
    try:
        print(f"      üìã Processando sociedade: {sociedade['NomeSoci']} ({sociedade['Insc']})")

        final_url = "https://cna.oab.org.br" + sociedade['Url']

        # Run the selenium function in thread pool with retry
        loop = asyncio.get_event_loop()
        modal_data = await loop.run_in_executor(
            executor,
            get_modal_data_with_selenium,
            final_url,
            25,  # timeout
            4,   # max_retries
            2    # retry_delay
        )

        if not modal_data or not modal_data.get('content_loaded', False):
            error_message = f"Failed to get modal data for sociedade {sociedade['Insc']} after all retries"
            print(f"      ‚ùå ERRO: {error_message}")
            error_log.append(error_message)
            return None

        # Combine all data into final result
        final_result = {
            'lawyer_info': {
                'lawyer_name': lawyer_name,
                'lawyer_state': state,
                'lawyer_insc': insc
            },
            'basic_info': {
                'Insc': sociedade['Insc'],
                'NomeSoci': sociedade['NomeSoci'],
                'IdtSoci': sociedade['IdtSoci'],
                'SiglUf': sociedade['SiglUf'],
                'source_url': final_url
            },
            'modal_data': modal_data,
            'processed_at': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        }

        # Save to S3 instead of local file
        filename = f"sociedade_{state}_{insc}_{sanitize_filename(sociedade['Insc'])}_{int(time.time())}.json"
        s3_url = save_to_s3_and_local_backup(final_result, filename)
        
        if s3_url:
            print(f"      ‚úÖ Sociedade salva: {filename}")
        else:
            print(f"      ‚ö†Ô∏è Problema ao salvar sociedade: {filename}")

        return final_result

    except Exception as e:
        error_message = f"Error processing sociedade {sociedade['Insc']}: {str(e)}"
        print(f"      ‚ùå ERRO: {error_message}")
        error_log.append(error_message)
        return None

def sanitize_filename(filename):
    """Remove invalid characters from filename"""
    return re.sub(r'[<>:"/\\|?*]', '_', filename)

async def search_lawyer_with_updates(insc, state, cookies, token, original_record, max_retries=4, retry_delay=2):
    """Search for lawyer and update record with external data, plus extract sociedades ASYNC with robust retry"""
    search_url = "https://cna.oab.org.br/Home/Search"
    search_data = {
        "__RequestVerificationToken": token,
        "IsMobile": "false",
        "NomeAdvo": "",
        "Insc": str(insc),
        "Uf": state,
        "TipoInsc": ""
    }
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
        "Content-Type": "application/json",
        "Accept": "application/json, text/javascript, */*; q=0.01",
    }

    # Create enhanced record structure
    enhanced_record = original_record.copy()
    enhanced_record['processed'] = True
    enhanced_record['has_society'] = False
    enhanced_record['corrected_full_name'] = None
    enhanced_record['society_link'] = None
    enhanced_record['society_basic_details'] = []
    enhanced_record['society_complete_details'] = []

    for attempt in range(max_retries):
        try:
            print(f"    üîç Tentativa {attempt + 1}: Buscando advogado...")
            
            # Step 1: Initial search with retry
            response = make_request_with_retry(
                'POST', 
                search_url, 
                max_retries=4,
                retry_delay=2,
                json=search_data, 
                headers=headers, 
                cookies=cookies
            )
            
            search_result = response.json()

            if not (search_result['Success'] and search_result['Data']):
                error_message = f"Search failed or no results found for {state} {insc}"
                print(f"    ‚ùå {error_message}")
                if attempt < max_retries - 1:
                    print(f"    ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                    time.sleep(retry_delay)
                    continue
                error_log.append(error_message)
                return enhanced_record, True

            # Compare and update full_name only if different
            external_name = search_result['Data'][0].get('Nome')
            original_name = enhanced_record.get('full_name', '').strip()

            if external_name and external_name.strip():
                external_name_clean = external_name.strip()
                if original_name.upper() != external_name_clean.upper():
                    print(f"    üîÑ NOME DIFERENTE - Atualizando:")
                    print(f"        Original: '{original_name}'")
                    print(f"        Correto:  '{external_name_clean}'")
                    enhanced_record['corrected_full_name'] = external_name_clean
                else:
                    print(f"    ‚úÖ Nome confere: '{original_name}'")

            # Step 2: Get detail URL with retry
            detail_url = "https://cna.oab.org.br" + search_result['Data'][0]['DetailUrl']
            enhanced_record['society_link'] = detail_url

            print(f"    üîç Buscando detalhes da sociedade...")
            detail_response = make_request_with_retry(
                'GET',
                detail_url,
                max_retries=4,
                retry_delay=2,
                headers=headers,
                cookies=cookies
            )
            
            detail_result = detail_response.json()

            if not (detail_result['Success'] and 'Sociedades' in detail_result['Data']):
                print(f"    ‚ÑπÔ∏è  Sem dados de sociedades para {enhanced_record['full_name']}")
                return enhanced_record, True

            # Process sociedades
            sociedades_data = detail_result['Data']['Sociedades']

            if sociedades_data is None or len(sociedades_data) == 0:
                print(f"    ‚ÑπÔ∏è  {enhanced_record['full_name']} n√£o possui sociedades")
                return enhanced_record, True

            # Update has_society flag
            enhanced_record['has_society'] = True
            
            # Store basic sociedades info
            basic_sociedades = []
            for soc in sociedades_data:
                basic_info = {
                    'Insc': soc['Insc'],
                    'NomeSoci': soc['NomeSoci'],
                    'IdtSoci': soc['IdtSoci'],
                    'SiglUf': soc['SiglUf'],
                    'Url': soc['Url']
                }
                basic_sociedades.append(basic_info)
            
            enhanced_record['society_basic_details'] = basic_sociedades

            print(f"    üè¢ Encontradas {len(sociedades_data)} sociedades - Processando detalhes...")

            # Process detailed sociedades data ASYNC
            with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:  # Reduced workers for headless
                tasks = []
                for sociedade in sociedades_data:
                    task = process_sociedade_async(
                        sociedade,
                        state,
                        insc,
                        enhanced_record.get('corrected_full_name') or enhanced_record['full_name'],
                        executor
                    )
                    tasks.append(task)

                sociedades_results = await asyncio.gather(*tasks, return_exceptions=True)

                # Process results
                complete_details = []
                for i, result in enumerate(sociedades_results):
                    if isinstance(result, Exception):
                        error_message = f"Async error processing sociedade {i}: {str(result)}"
                        print(f"    ‚ùå ERRO: {error_message}")
                        error_log.append(error_message)
                    elif result is not None:
                        complete_details.append(result)
                        print(f"      ‚úÖ {result['basic_info']['NomeSoci']} ({result['basic_info']['SiglUf']})")

                enhanced_record['society_complete_details'] = complete_details

            print(f"    üéâ Processamento completo - {len(complete_details)} sociedades processadas")
            return enhanced_record, True

        except RequestException as e:
            if hasattr(e, 'response') and e.response and e.response.status_code in [401, 403, 419] or "token" in str(e).lower():
                print(f"    üîÑ Sess√£o expirada: {str(e)}")
                return enhanced_record, False

            print(f"    ‚ö†Ô∏è  Tentativa {attempt + 1} falhou (RequestException): {str(e)}")
            if attempt < max_retries - 1:
                print(f"    ‚è≥ Tentando novamente em {retry_delay} segundos...")
                time.sleep(retry_delay)
            else:
                error_message = f"Max retries exceeded for {state} {insc}: {str(e)}"
                print(f"    ‚ùå {error_message}")
                error_log.append(error_message)
                return enhanced_record, True
        except Exception as e:
            print(f"    ‚ö†Ô∏è  Tentativa {attempt + 1} falhou (Exception): {str(e)}")
            if attempt < max_retries - 1:
                print(f"    ‚è≥ Tentando novamente em {retry_delay} segundos...")
                time.sleep(retry_delay)
            else:
                error_message = f"Unexpected error for {state} {insc}: {str(e)}"
                print(f"    ‚ùå {error_message}")
                error_log.append(error_message)
                return enhanced_record, True

    return enhanced_record, True

def save_enhanced_lawyers_to_file(enhanced_lawyers_list, batch_name, batch_num=None, emergency=False):
    """Save enhanced lawyer records to S3 and local backup"""
    if not enhanced_lawyers_list:
        print("  Nenhum advogado para salvar")
        return None

    # Extract batch name without extension for filename
    batch_base = os.path.splitext(os.path.basename(batch_name))[0]
    
    if emergency:
        filename = f"lawyers_enhanced_{batch_base}_EMERGENCY_{time.strftime('%Y%m%d_%H%M%S')}.json"
    elif batch_num is not None:
        filename = f"lawyers_enhanced_{batch_base}_part_{batch_num:03d}_{time.strftime('%Y%m%d_%H%M%S')}.json"
    else:
        filename = f"lawyers_enhanced_{batch_base}_FINAL_{time.strftime('%Y%m%d_%H%M%S')}.json"

    # Save to S3 and local backup
    s3_url = save_to_s3_and_local_backup(enhanced_lawyers_list, filename)
    
    if s3_url:
        print(f"  ‚úÖ Salvos {len(enhanced_lawyers_list)} registros de advogados em {filename}")
        return s3_url
    else:
        print(f"  ‚ö†Ô∏è Problema ao salvar {len(enhanced_lawyers_list)} registros")
        return filename

def cleanup_memory():
    """Clean up memory"""
    gc.collect()

def test_driver_compatibility():
    """Test driver compatibility and report system status"""
    print("üîß TESTANDO COMPATIBILIDADE DE DRIVERS...")
    print("="*60)
    
    # Test Chrome
    print("üåê Testando Chrome...")
    try:
        chrome_driver = driver_manager.get_chrome_driver_robust(max_attempts=2)
        if chrome_driver:
            print("‚úÖ Chrome: FUNCIONANDO")
            chrome_driver.quit()
        else:
            print("‚ùå Chrome: FALHOU")
    except Exception as e:
        print(f"‚ùå Chrome: ERRO - {e}")
    
    # Test Firefox  
    print("\nü¶ä Testando Firefox...")
    try:
        firefox_driver = driver_manager.get_firefox_driver_robust(max_attempts=2)
        if firefox_driver:
            print("‚úÖ Firefox: FUNCIONANDO")
            firefox_driver.quit()
        else:
            print("‚ùå Firefox: FALHOU")
    except Exception as e:
        print(f"‚ùå Firefox: ERRO - {e}")
    
    # Test Edge
    print("\nüî∑ Testando Edge...")
    try:
        edge_driver = driver_manager.get_edge_driver_robust(max_attempts=2)
        if edge_driver:
            print("‚úÖ Edge: FUNCIONANDO")
            edge_driver.quit()
        else:
            print("‚ùå Edge: FALHOU")
    except Exception as e:
        print(f"‚ùå Edge: ERRO - {e}")
    
    print("\n" + "="*60)
    print(f"üñ•Ô∏è  Sistema: {driver_manager.system_info}")
    print(f"üìÅ Diret√≥rio de drivers: {driver_manager.drivers_dir}")

def setup_system_dependencies():
    """Setup system dependencies if needed"""
    if "--install-deps" in sys.argv:
        print("üîß Instalando depend√™ncias do sistema...")
        driver_manager.install_system_dependencies()
        return True
    return False

async def main():
    """Main async function to process batch of lawyers"""
    global enhanced_lawyers, current_batch_file, error_log, batch_counter
    
    # Check for command line argument
    if len(sys.argv) < 2:
        print("‚ùå Uso: python script.py <arquivo_batch.json> [op√ß√µes]")
        print("   Exemplo: python script.py lawyers_batch_01.json")
        print("   Op√ß√µes:")
        print("     --test-drivers     : Testar compatibilidade de drivers")
        print("     --install-deps     : Instalar depend√™ncias do sistema")
        print("     --help            : Mostrar esta ajuda")
        sys.exit(1)

    if "--help" in sys.argv:
        print("üöÄ OAB Scraper v3 - Robust Selenium Driver Management")
        print("="*60)
        print("RECURSOS:")
        print("  ‚úÖ Suporte para Chrome, Firefox e Edge")
        print("  ‚úÖ Download autom√°tico de drivers")
        print("  ‚úÖ Fallbacks robustos para ambientes servidor")
        print("  ‚úÖ Cache de drivers e detec√ß√£o de bin√°rios")
        print("  ‚úÖ Modo headless otimizado")
        print("  ‚úÖ Upload autom√°tico para S3")
        print("  ‚úÖ Sistema de retry avan√ßado")
        print("\nUSO:")
        print("  python script.py arquivo.json              # Executar normalmente")
        print("  python script.py arquivo.json --test-drivers  # Testar drivers")
        print("  python script.py arquivo.json --install-deps  # Instalar deps")
        print("\nREQUISITOS:")
        print("  - Arquivo .env com credenciais AWS e proxy")
        print("  - Python 3.7+ com selenium, boto3, requests")
        print("  - Pelo menos um browser instalado (Chrome/Firefox/Edge)")
        return

    batch_file = sys.argv[1]
    test_drivers = "--test-drivers" in sys.argv

    # Setup system dependencies if requested
    setup_system_dependencies()

    # Run driver compatibility test if requested
    if test_drivers:
        test_driver_compatibility()
        return

    current_batch_file = batch_file  # Set global for signal handler
    
    # Check if file exists
    if not os.path.exists(batch_file):
        print(f"‚ùå Arquivo n√£o encontrado: {batch_file}")
        sys.exit(1)

    # Verify proxy connection at startup (silent)
    print("üîÑ Verificando conex√£o proxy...")
    if verify_proxy_connection():
        proxy_ip_data = get_current_ip()
        if proxy_ip_data:
            print(f"‚úÖ Proxy ativo: {proxy_ip_data.get('ip', 'unknown')} ({proxy_ip_data.get('country', 'unknown')})")
            save_ip_log(proxy_ip_data, "proxy_ip_log.json")
    else:
        print("‚ö†Ô∏è AVISO: N√£o foi poss√≠vel verificar a conex√£o proxy.")

    error_log = []
    enhanced_lawyers = []
    batch_counter = 0
    BATCH_SIZE = 400  # Save every 400 lawyers

    try:
        with open(batch_file, 'r', encoding='utf-8') as f:
            lawyers_data = json.load(f)

        # Clean state field for all records
        for record in lawyers_data:
            if 'state' in record:
                original_state = record['state']
                record['state'] = clean_state(original_state)
                if original_state != record['state']:
                    print(f"üßπ Estado corrigido: '{original_state}' -> '{record['state']}'")

        # Filter records that need processing
        records_to_process = []
        records_skipped = []
        
        for record in lawyers_data:
            should_process, reason = should_process_record(record)
            if should_process:
                records_to_process.append(record)
            else:
                records_skipped.append(record)
                enhanced_lawyers.append(record)  # Add skipped records to final list

        print(f"üìä AN√ÅLISE DE REGISTROS:")
        print(f"  - Total de registros: {len(lawyers_data)}")
        print(f"  - Para processar: {len(records_to_process)}")
        print(f"  - J√° completos (pulados): {len(records_skipped)}")
        print(f"üíæ Salvamento autom√°tico a cada {BATCH_SIZE} advogados")
        print(f"üñ•Ô∏è  Sistema: {driver_manager.system_info['os']} {driver_manager.system_info['arch']} ({driver_manager.system_info['distro']})")
        print(f"üîß WebDriverManager: {'Dispon√≠vel' if WEBDRIVER_MANAGER_AVAILABLE else 'Indispon√≠vel (usando downloads manuais)'}")
        print(f"üîÑ Sistema de retry robusto: Multiple browsers com fallbacks")
        print(f"‚òÅÔ∏è  Dados salvos no S3: s3://{AWS_BUCKET}/oab_data/")
        
        if not records_to_process:
            print("‚úÖ Todos os registros j√° est√£o completos. Nada para processar.")
            # Save final file with all records
            final_filename = save_enhanced_lawyers_to_file(enhanced_lawyers, batch_file)
            print(f"üìÅ Arquivo final salvo: {final_filename}")
            return

        print("=" * 80)

        # Get initial cookies and token with retry
        print("üç™ Obtendo cookies e token iniciais...")
        cookies, token = get_initial_cookies(max_retries=4, retry_delay=2)
        print("‚úÖ Cookies e token obtidos")

        # Process only the records that need processing
        for i, record in enumerate(records_to_process):
            try:
                insc = record.get('oab_number')
                state = record.get('state')
                lawyer_id = record.get('id')
                full_name = record.get('full_name', 'Unknown')

                if not insc or not state:
                    error_message = f"Dados faltando - ID: {lawyer_id}, Nome: {full_name}"
                    error_log.append(error_message)
                    enhanced_lawyers.append(record)
                    continue

                print(f"\n[{i+1}/{len(records_to_process)}] üë®‚Äçüíº {full_name} ({state} {insc})")
                
                # Show why this record is being processed
                _, reason = should_process_record(record)
                print(f"    üìã Motivo: {reason}")

                # Process lawyer with retry system
                enhanced_record, cookies_valid = await search_lawyer_with_updates(
                    insc, state, cookies, token, record, max_retries=4, retry_delay=2
                )

                # If cookies are invalid, get new ones and retry
                if not cookies_valid:
                    print("    üîÑ Renovando cookies...")
                    cookies, token = get_initial_cookies(max_retries=4, retry_delay=2)
                    enhanced_record, _ = await search_lawyer_with_updates(
                        insc, state, cookies, token, record, max_retries=2, retry_delay=2
                    )

                enhanced_lawyers.append(enhanced_record)
                
                sociedades_count = len(enhanced_record.get('society_complete_details', []))
                has_society = enhanced_record.get('has_society', False)
                name_corrected = enhanced_record.get('corrected_full_name') is not None
                
                status_parts = []
                if has_society:
                    status_parts.append(f"{sociedades_count} sociedades")
                else:
                    status_parts.append("sem sociedades")
                    
                if name_corrected:
                    status_parts.append("nome corrigido")
                
                print(f"    ‚úÖ Conclu√≠do: {', '.join(status_parts)}")

                # Save every BATCH_SIZE lawyers (including skipped ones)
                if len(enhanced_lawyers) % BATCH_SIZE == 0:
                    batch_counter += 1
                    print(f"\nüíæ SALVAMENTO AUTOM√ÅTICO - LOTE {batch_counter}")
                    save_enhanced_lawyers_to_file(enhanced_lawyers, batch_file, batch_counter)
                    
                    # Clean up memory
                    print("üßπ Limpando mem√≥ria...")
                    cleanup_memory()
                    processed_count = i + 1
                    total_progress = len(records_skipped) + processed_count
                    print(f"üìä Progresso: {processed_count}/{len(records_to_process)} processados, {total_progress}/{len(lawyers_data)} total ({(total_progress/len(lawyers_data)*100):.1f}%)")
                    print("-" * 50)

                time.sleep(1.2)

            except Exception as e:
                error_message = f"Erro processando {state} {insc} - {full_name}: {str(e)}"
                print(f"üí• ERRO GERAL: {error_message}")
                error_log.append(error_message)
                enhanced_lawyers.append(record)

        print("\n" + "=" * 80)
        print("üíæ SALVANDO RESULTADOS FINAIS...")

        # Save final results
        if enhanced_lawyers:
            final_filename = save_enhanced_lawyers_to_file(enhanced_lawyers, batch_file)
        else:
            final_filename = "Nenhum dado para salvar"

        print(f"\nüéâ PROCESSAMENTO CONCLU√çDO!")
        print(f"üìä RESUMO:")
        print(f"  - Arquivo processado: {os.path.basename(batch_file)}")
        print(f"  - Total de registros: {len(lawyers_data)}")
        print(f"  - Registros processados: {len(records_to_process)}")
        print(f"  - Registros j√° completos (pulados): {len(records_skipped)}")
        print(f"  - Com sociedades: {sum(1 for l in enhanced_lawyers if l.get('has_society'))}")
        print(f"  - Nomes corrigidos: {sum(1 for l in enhanced_lawyers if l.get('corrected_full_name'))}")
        print(f"  - Estados corrigidos: {sum(1 for record in lawyers_data if clean_state(record.get('state', '')) != record.get('state', ''))}")
        print(f"  - Erros encontrados: {len(error_log)}")
        print(f"  - Lotes salvos: {batch_counter}")
        print(f"  - Arquivo final: {final_filename}")
        print(f"  - Bucket S3: s3://{AWS_BUCKET}/oab_data/")
        print(f"  - Sistema utilizado: {driver_manager.system_info['platform']}")
        print(f"  - WebDriverManager: {'Usado' if WEBDRIVER_MANAGER_AVAILABLE else 'Downloads manuais'}")

        if error_log:
            batch_base = os.path.splitext(os.path.basename(batch_file))[0]
            error_file_name = f"error_log_{batch_base}_FINAL_{time.strftime('%Y%m%d_%H%M%S')}.txt"
            error_content = f"Log de Erros Final - {batch_file}\n" + "="*50 + "\n\n" + "\n".join(error_log)
            save_to_s3_and_local_backup(error_content, error_file_name, 'text/plain')
            print(f"  - Log de erros: {error_file_name}")

    except Exception as e:
        print(f"üí• Erro cr√≠tico processando {batch_file}: {str(e)}")
    finally:
        # Cleanup driver manager
        try:
            driver_manager.cleanup()
            print("üßπ Limpeza de drivers conclu√≠da")
        except:
            pass

if __name__ == "__main__":
    print("üöÄ OAB Scraper v3 - Robust Selenium Driver Management")
    print("="*60)
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüõë Script interrompido pelo usu√°rio")
        try:
            driver_manager.cleanup()
        except:
            pass
        sys.exit(0)
    except Exception as e:
        print(f"üí• Erro cr√≠tico no script: {e}")
        try:
            driver_manager.cleanup()
        except:
            pass
        sys.exit(1)

# ============================================================================
# INSTALLATION HELPER FUNCTIONS
# ============================================================================

def print_installation_guide():
    """Print installation guide for different systems"""
    print("""
üîß GUIA DE INSTALA√á√ÉO - OAB Scraper v3
======================================

DEPEND√äNCIAS PYTHON:
pip install selenium webdriver-manager beautifulsoup4 requests boto3 python-dotenv

UBUNTU/DEBIAN:
sudo apt update
sudo apt install -y wget curl unzip
wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
echo 'deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main' | sudo tee /etc/apt/sources.list.d/google-chrome.list
sudo apt update
sudo apt install -y google-chrome-stable firefox-esr

CENTOS/RHEL:
sudo yum update -y
sudo yum install -y wget curl unzip
sudo yum install -y google-chrome-stable firefox

ALPINE LINUX:
sudo apk update
sudo apk add --no-cache chromium firefox wget curl unzip

ARQUIVO .env (obrigat√≥rio):
PROXY_USERNAME=seu_usuario
PROXY_PASSWORD=sua_senha
PROXY_HOST=host:porta
AWS_ACCESS_KEY_ID=sua_key
AWS_SECRET_ACCESS_KEY=sua_secret
AWS_BUCKET=seu_bucket
AWS_DEFAULT_REGION=us-east-1

USO:
python script.py arquivo.json                # Executar
python script.py arquivo.json --test-drivers # Testar drivers
python script.py arquivo.json --install-deps # Instalar deps
python script.py arquivo.json --help         # Ajuda
""")

def check_system_requirements():
    """Check if system meets requirements"""
    print("üîç VERIFICANDO REQUISITOS DO SISTEMA...")
    
    requirements_met = True
    
    # Check Python version
    if sys.version_info < (3, 7):
        print("‚ùå Python 3.7+ necess√°rio")
        requirements_met = False
    else:
        print(f"‚úÖ Python {sys.version_info.major}.{sys.version_info.minor}")
    
    # Check required modules
    required_modules = ['selenium', 'requests', 'boto3', 'bs4']
    for module in required_modules:
        try:
            __import__(module)
            print(f"‚úÖ {module}")
        except ImportError:
            print(f"‚ùå {module} n√£o instalado")
            requirements_met = False
    
    # Check webdriver-manager
    if WEBDRIVER_MANAGER_AVAILABLE:
        print("‚úÖ webdriver-manager")
    else:
        print("‚ö†Ô∏è webdriver-manager n√£o instalado (opcional)")
    
    # Check .env file
    if os.path.exists('.env'):
        print("‚úÖ Arquivo .env encontrado")
    else:
        print("‚ùå Arquivo .env n√£o encontrado")
        requirements_met = False
    
    # Check browsers
    chrome_found = driver_manager._find_chrome_binary()
    firefox_found = driver_manager._find_firefox_binary()
    
    if chrome_found:
        print(f"‚úÖ Chrome/Chromium encontrado")
    else:
        print("‚ö†Ô∏è Chrome/Chromium n√£o encontrado")
    
    if firefox_found:
        print(f"‚úÖ Firefox encontrado")
    else:
        print("‚ö†Ô∏è Firefox n√£o encontrado")
    
    if not chrome_found and not firefox_found:
        print("‚ùå Nenhum browser encontrado")
        requirements_met = False
    
    print(f"\n{'‚úÖ SISTEMA PRONTO' if requirements_met else '‚ùå REQUISITOS N√ÉO ATENDIDOS'}")
    
    if not requirements_met:
        print("\nüîß Execute o comando de instala√ß√£o para seu sistema:")
        print_installation_guide()
    
    return requirements_met

# Add command line check for requirements
if "--check-requirements" in sys.argv:
    check_system_requirements()
    sys.exit(0)

if "--installation-guide" in sys.argv:
    print_installation_guide()
    sys.exit(0)#!/usr/bin/env python3
"""
OAB Scraper v3 - Robust Selenium Driver Management
Complete implementation with multiple browser fallbacks and server optimization
"""

import time
import requests
import os
import sys
import signal
import gc
import asyncio
import concurrent.futures
import platform
import subprocess
import shutil
import zipfile
import tempfile
import urllib.request
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.edge.options import Options as EdgeOptions
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
from requests.exceptions import RequestException
from bs4 import BeautifulSoup
import json
import re
import logging
try:
    from webdriver_manager.chrome import ChromeDriverManager
    from webdriver_manager.firefox import GeckoDriverManager
    from webdriver_manager.microsoft import EdgeChromiumDriverManager
    WEBDRIVER_MANAGER_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è webdriver-manager n√£o instalado. Usando apenas downloads manuais.")
    WEBDRIVER_MANAGER_AVAILABLE = False

import boto3
from botocore.exceptions import ClientError, NoCredentialsError
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("oab_scraper")

# Get credentials from environment variables
PROXY_USERNAME = os.getenv('PROXY_USERNAME')
PROXY_PASSWORD = os.getenv('PROXY_PASSWORD')
PROXY_HOST = os.getenv('PROXY_HOST')

# AWS Configuration
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
AWS_BUCKET = os.getenv('AWS_BUCKET')
AWS_DEFAULT_REGION = os.getenv('AWS_DEFAULT_REGION')

# Validate environment variables
required_env_vars = {
    'PROXY_USERNAME': PROXY_USERNAME,
    'PROXY_PASSWORD': PROXY_PASSWORD,
    'PROXY_HOST': PROXY_HOST,
    'AWS_ACCESS_KEY_ID': AWS_ACCESS_KEY_ID,
    'AWS_SECRET_ACCESS_KEY': AWS_SECRET_ACCESS_KEY,
    'AWS_BUCKET': AWS_BUCKET,
    'AWS_DEFAULT_REGION': AWS_DEFAULT_REGION
}

missing_vars = [var for var, value in required_env_vars.items() if not value]
if missing_vars:
    print(f"‚ùå Vari√°veis de ambiente faltando: {', '.join(missing_vars)}")
    print("   Certifique-se de ter um arquivo .env com todas as credenciais necess√°rias")
    sys.exit(1)

PROXY_URL = f"http://{PROXY_USERNAME}:{PROXY_PASSWORD}@{PROXY_HOST}"

PROXY_CONFIG = {
    'http': PROXY_URL,
    'https': PROXY_URL
}

# Initialize AWS S3 client
try:
    s3_client = boto3.client(
        's3',
        aws_access_key_id=AWS_ACCESS_KEY_ID,
        aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
        region_name=AWS_DEFAULT_REGION
    )
    # Test S3 connection
    s3_client.head_bucket(Bucket=AWS_BUCKET)
    print(f"‚úÖ Conex√£o S3 estabelecida com bucket: {AWS_BUCKET}")
except NoCredentialsError:
    print("‚ùå Credenciais AWS inv√°lidas")
    sys.exit(1)
except ClientError as e:
    error_code = e.response['Error']['Code']
    if error_code == '404':
        print(f"‚ùå Bucket S3 n√£o encontrado: {AWS_BUCKET}")
    else:
        print(f"‚ùå Erro ao conectar com S3: {e}")
    sys.exit(1)
except Exception as e:
    print(f"‚ùå Erro na configura√ß√£o AWS: {e}")
    sys.exit(1)

# Global variables for signal handler
enhanced_lawyers = []
current_batch_file = ""
error_log = []
batch_counter = 0

# Initialize error log
error_log = []

# ============================================================================
# ROBUST WEBDRIVER MANAGEMENT SYSTEM V3
# ============================================================================

class RobustDriverManager:
    """Advanced WebDriver manager with comprehensive fallback system"""
    
    def __init__(self):
        self.drivers_dir = os.path.expanduser("~/webdrivers")
        self.temp_dir = tempfile.mkdtemp(prefix="webdriver_robust_")
        self.system_info = self._get_system_info()
        self.proxy_config = self._get_proxy_config()
        self.driver_cache = {}
        self.tested_combinations = set()
        
        # Create drivers directory
        os.makedirs(self.drivers_dir, exist_ok=True)
        
        print(f"üñ•Ô∏è  Sistema detectado: {self.system_info['os']} {self.system_info['arch']}")
        print(f"üìÅ Diret√≥rio de drivers: {self.drivers_dir}")
        print(f"üîß WebDriverManager dispon√≠vel: {WEBDRIVER_MANAGER_AVAILABLE}")
    
    def _get_system_info(self):
        """Get comprehensive system information"""
        system = platform.system().lower()
        machine = platform.machine().lower()
        
        # Determine OS
        if system == "linux":
            os_type = "linux"
            # Check for specific distributions
            try:
                with open('/etc/os-release', 'r') as f:
                    content = f.read().lower()
                    if 'ubuntu' in content:
                        distro = 'ubuntu'
                    elif 'debian' in content:
                        distro = 'debian'
                    elif 'centos' in content or 'rhel' in content:
                        distro = 'rhel'
                    elif 'alpine' in content:
                        distro = 'alpine'
                    else:
                        distro = 'unknown'
            except:
                distro = 'unknown'
        elif system == "darwin":
            os_type = "mac"
            distro = 'macos'
        elif system == "windows":
            os_type = "win"
            distro = 'windows'
        else:
            os_type = "linux"  # Default fallback
            distro = 'unknown'
        
        # Determine architecture
        if machine in ["x86_64", "amd64"]:
            arch = "64"
        elif machine in ["i386", "i686", "x86"]:
            arch = "32"
        elif machine in ["aarch64", "arm64"]:
            arch = "arm64"
        elif machine.startswith("arm"):
            arch = "arm"
        else:
            arch = "64"  # Default fallback
        
        return {
            "os": os_type,
            "arch": arch,
            "platform": f"{os_type}{arch}",
            "system": system,
            "machine": machine,
            "distro": distro,
            "python_version": sys.version_info
        }
    
    def _get_proxy_config(self):
        """Get proxy configuration for webdrivers"""
        if not all([PROXY_HOST, PROXY_USERNAME, PROXY_PASSWORD]):
            return None
            
        try:
            host, port = PROXY_HOST.split(':')
            return {
                'host': host,
                'port': int(port),
                'username': PROXY_USERNAME,
                'password': PROXY_PASSWORD,
                'url': PROXY_URL
            }
        except Exception as e:
            logger.error(f"Error parsing proxy config: {e}")
            return None
    
    def _check_driver_exists(self, driver_path):
        """Check if driver exists and is executable"""
        if not os.path.exists(driver_path):
            return False
        
        # Check if file is executable
        if not os.access(driver_path, os.X_OK):
            try:
                os.chmod(driver_path, 0o755)
            except:
                return False
        
        return True
    
    def _get_chrome_version(self):
        """Try to get installed Chrome version"""
        chrome_paths = self._find_chrome_binary()
        if not chrome_paths:
            return None
            
        chrome_path = chrome_paths[0] if isinstance(chrome_paths, list) else chrome_paths
        
        try:
            # Try to get version
            result = subprocess.run([chrome_path, '--version'], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                version_text = result.stdout.strip()
                # Extract version number
                import re
                match = re.search(r'(\d+\.\d+\.\d+\.\d+)', version_text)
                if match:
                    return match.group(1)
        except:
            pass
        
        return None
    
    def _download_chromedriver_manual(self, version="stable"):
        """Enhanced ChromeDriver download with version matching"""
        try:
            print(f"üì• Baixando ChromeDriver manualmente...")
            
            # Get Chrome version if available
            chrome_version = self._get_chrome_version()
            if chrome_version and version == "stable":
                # Use major version for compatibility
                major_version = chrome_version.split('.')[0]
                print(f"üîç Chrome detectado: v{chrome_version}, buscando driver v{major_version}")
            
            # Modern ChromeDriver API (post-114)
            if version == "stable":
                try:
                    # Try new API first (Chrome 115+)
                    api_url = "https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions-with-downloads.json"
                    with urllib.request.urlopen(api_url, timeout=15) as response:
                        data = json.loads(response.read().decode())
                        stable_version = data['channels']['Stable']['version']
                        downloads = data['channels']['Stable']['downloads']['chromedriver']
                        
                        # Find matching platform
                        platform_key = self._get_chromedriver_platform()
                        matching_download = None
                        
                        for download in downloads:
                            if download['platform'] == platform_key:
                                matching_download = download
                                break
                        
                        if matching_download:
                            download_url = matching_download['url']
                            version = stable_version
                            print(f"üîó Usando Chrome for Testing API: {download_url}")
                        else:
                            raise Exception("Platform not found in new API")
                            
                except Exception as e:
                    print(f"‚ö†Ô∏è Nova API falhou: {e}, tentando API legada...")
                    # Fallback to legacy API
                    version_url = "https://chromedriver.storage.googleapis.com/LATEST_RELEASE"
                    try:
                        with urllib.request.urlopen(version_url, timeout=10) as response:
                            latest_version = response.read().decode().strip()
                            version = latest_version
                    except:
                        version = "119.0.6045.105"  # Fallback version
                    
                    platform_str = self._get_chromedriver_platform_legacy()
                    download_url = f"https://chromedriver.storage.googleapis.com/{version}/chromedriver_{platform_str}.zip"
            
            # Download and extract
            zip_path = os.path.join(self.temp_dir, f"chromedriver_{version}.zip")
            
            print(f"üì• Baixando: {download_url}")
            urllib.request.urlretrieve(download_url, zip_path)
            
            # Extract
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(self.temp_dir)
            
            # Find the extracted driver (new format may have subdirectories)
            driver_name = "chromedriver.exe" if self.system_info['os'] == 'win' else "chromedriver"
            driver_path = None
            
            # Search in extracted directories
            for root, dirs, files in os.walk(self.temp_dir):
                if driver_name in files:
                    driver_path = os.path.join(root, driver_name)
                    break
            
            if driver_path and os.path.exists(driver_path):
                # Move to permanent location
                final_path = os.path.join(self.drivers_dir, f"chromedriver_{version}")
                if self.system_info['os'] == 'win':
                    final_path += ".exe"
                
                shutil.move(driver_path, final_path)
                os.chmod(final_path, 0o755)
                
                print(f"‚úÖ ChromeDriver baixado: {final_path}")
                return final_path
            else:
                print(f"‚ùå Driver n√£o encontrado ap√≥s extra√ß√£o")
                return None
                
        except Exception as e:
            print(f"‚ùå Erro no download manual do ChromeDriver: {e}")
            return None
    
    def _get_chromedriver_platform(self):
        """Get platform string for new Chrome for Testing API"""
        mapping = {
            "linux64": "linux64",
            "linux32": "linux64",  # 32-bit not supported in new API
            "mac64": "mac-x64",
            "macarm64": "mac-arm64",
            "win64": "win64",
            "win32": "win32"
        }
        
        platform_key = f"{self.system_info['os']}{self.system_info['arch']}"
        if self.system_info['os'] == 'mac' and self.system_info['arch'] == 'arm64':
            platform_key = 'macarm64'
        
        return mapping.get(platform_key, "linux64")
    
    def _get_chromedriver_platform_legacy(self):
        """Get platform string for legacy ChromeDriver API"""
        mapping = {
            "linux64": "linux64",
            "linux32": "linux32",
            "mac64": "mac64",
            "macarm64": "mac_arm64",
            "win64": "win32",
            "win32": "win32"
        }
        
        platform_key = f"{self.system_info['os']}{self.system_info['arch']}"
        if self.system_info['os'] == 'mac' and self.system_info['arch'] == 'arm64':
            platform_key = 'macarm64'
        
        return mapping.get(platform_key, "linux64")
    
    def _download_geckodriver_manual(self, version="latest"):
        """Enhanced GeckoDriver download"""
        try:
            print(f"üì• Baixando GeckoDriver manualmente...")
            
            # GitHub API to get latest release
            if version == "latest":
                api_url = "https://api.github.com/repos/mozilla/geckodriver/releases/latest"
                try:
                    with urllib.request.urlopen(api_url, timeout=15) as response:
                        release_data = json.loads(response.read().decode())
                        version = release_data['tag_name']
                        print(f"üîç Vers√£o mais recente: {version}")
                except:
                    version = "v0.34.0"  # Updated fallback version
            
            # Build download URL
            platform_mapping = {
                "linux64": "linux64",
                "linux32": "linux32", 
                "mac64": "macos",
                "macarm64": "macos-aarch64",
                "win64": "win64",
                "win32": "win32"
            }
            
            platform_key = f"{self.system_info['os']}{self.system_info['arch']}"
            if self.system_info['os'] == 'mac' and self.system_info['arch'] == 'arm64':
                platform_key = 'macarm64'
            
            platform_str = platform_mapping.get(platform_key, "linux64")
            
            # Determine file extension
            file_ext = "zip" if self.system_info['os'] == 'win' else "tar.gz"
            
            download_url = f"https://github.com/mozilla/geckodriver/releases/download/{version}/geckodriver-{version}-{platform_str}.{file_ext}"
            
            # Download and extract
            archive_path = os.path.join(self.temp_dir, f"geckodriver.{file_ext}")
            
            print(f"üì• Baixando: {download_url}")
            urllib.request.urlretrieve(download_url, archive_path)
            
            # Extract based on file type
            if file_ext == "zip":
                with zipfile.ZipFile(archive_path, 'r') as zip_ref:
                    zip_ref.extractall(self.temp_dir)
            else:
                import tarfile
                with tarfile.open(archive_path, 'r:gz') as tar_ref:
                    tar_ref.extractall(self.temp_dir)
            
            # Find the extracted driver
            driver_name = "geckodriver.exe" if self.system_info['os'] == 'win' else "geckodriver"
            driver_path = os.path.join(self.temp_dir, driver_name)
            
            if os.path.exists(driver_path):
                # Move to permanent location
                final_path = os.path.join(self.drivers_dir, f"geckodriver_{version}")
                if self.system_info['os'] == 'win':
                    final_path += ".exe"
                
                shutil.move(driver_path, final_path)
                os.chmod(final_path, 0o755)
                
                print(f"‚úÖ GeckoDriver baixado: {final_path}")
                return final_path
            else:
                print(f"‚ùå Driver n√£o encontrado ap√≥s extra√ß√£o")
                return None
                
        except Exception as e:
            print(f"‚ùå Erro no download manual do GeckoDriver: {e}")
            return None
    
    def _find_chrome_binary(self):
        """Enhanced Chrome binary detection"""
        possible_paths = [
            # Linux - Common locations
            "/usr/bin/google-chrome",
            "/usr/bin/google-chrome-stable", 
            "/usr/bin/google-chrome-beta",
            "/usr/bin/google-chrome-dev",
            "/usr/bin/chromium",
            "/usr/bin/chromium-browser",
            "/snap/bin/chromium",
            "/opt/google/chrome/chrome",
            "/opt/google/chrome/google-chrome",
            
            # AppImage and Flatpak
            "/var/lib/flatpak/exports/bin/com.google.Chrome",
            
            # macOS
            "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            "/Applications/Chromium.app/Contents/MacOS/Chromium",
            "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
            "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
            
            # Windows (WSL)
            "/mnt/c/Program Files/Google/Chrome/Application/chrome.exe",
            "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        ]
        
        found_binaries = []
        
        # Check predefined paths
        for path in possible_paths:
            if os.path.exists(path):
                found_binaries.append(path)
                print(f"üîç Chrome encontrado: {path}")
        
        # Try which/where command
        commands_to_try = ['google-chrome', 'google-chrome-stable', 'chromium', 'chromium-browser']
        
        for cmd in commands_to_try:
            try:
                result = subprocess.run(['which', cmd], capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and result.stdout.strip():
                    path = result.stdout.strip()
                    if path not in found_binaries:
                        found_binaries.append(path)
                        print(f"üîç Chrome encontrado via which: {path}")
            except:
                pass
        
        # Special handling for different distributions
        if self.system_info['distro'] == 'alpine':
            alpine_paths = ['/usr/bin/chromium', '/usr/bin/chromium-browser']
            for path in alpine_paths:
                if os.path.exists(path) and path not in found_binaries:
                    found_binaries.append(path)
        
        if not found_binaries:
            print("‚ö†Ô∏è Chrome/Chromium n√£o encontrado no sistema")
            return None
        
        return found_binaries[0] if len(found_binaries) == 1 else found_binaries
    
    def _find_firefox_binary(self):
        """Enhanced Firefox binary detection"""
        possible_paths = [
            # Linux
            "/usr/bin/firefox",
            "/usr/bin/firefox-esr",
            "/snap/bin/firefox",
            "/opt/firefox/firefox",
            "/usr/lib/firefox/firefox",
            
            # Flatpak
            "/var/lib/flatpak/exports/bin/org.mozilla.firefox",
            
            # macOS
            "/Applications/Firefox.app/Contents/MacOS/firefox",
            "/Applications/Firefox Developer Edition.app/Contents/MacOS/firefox",
            
            # Windows (WSL)
            "/mnt/c/Program Files/Mozilla Firefox/firefox.exe",
            "/mnt/c/Program Files (x86)/Mozilla Firefox/firefox.exe",
        ]
        
        found_binaries = []
        
        # Check predefined paths
        for path in possible_paths:
            if os.path.exists(path):
                found_binaries.append(path)
                print(f"üîç Firefox encontrado: {path}")
        
        # Try which command
        commands_to_try = ['firefox', 'firefox-esr']
        
        for cmd in commands_to_try:
            try:
                result = subprocess.run(['which', cmd], capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and result.stdout.strip():
                    path = result.stdout.strip()
                    if path not in found_binaries:
                        found_binaries.append(path)
                        print(f"üîç Firefox encontrado via which: {path}")
            except:
                pass
        
        if not found_binaries:
            print("‚ö†Ô∏è Firefox n√£o encontrado no sistema")
            return None
        
        return found_binaries[0] if len(found_binaries) == 1 else found_binaries
    
    def get_chrome_driver_robust(self, max_attempts=5):
        """Get Chrome driver with comprehensive fallback methods"""
        attempts = []
        
        # Add WebDriverManager if available
        if WEBDRIVER_MANAGER_AVAILABLE:
            attempts.append(("WebDriverManager", self._try_webdriver_manager_chrome))
        
        # Add other methods
        attempts.extend([
            ("Manual Download", self._try_manual_chrome_download),
            ("System PATH", self._try_system_chrome),
            ("Cached Driver", self._try_cached_chrome),
            ("Alternative Download", self._try_alternative_chrome_download)
        ])
        
        for attempt_num, (method_name, method) in enumerate(attempts):
            if attempt_num >= max_attempts:
                break
                
            try:
                print(f"üîÑ Tentativa {attempt_num + 1}: {method_name}")
                driver = method()
                if driver:
                    print(f"‚úÖ Chrome driver criado via: {method_name}")
                    return driver
            except Exception as e:
                print(f"‚ö†Ô∏è {method_name} falhou: {str(e)}")
                continue
        
        print("‚ùå Todas as tentativas de Chrome falharam")
        return None
    
    def _try_webdriver_manager_chrome(self):
        """Try using WebDriverManager for Chrome"""
        if not WEBDRIVER_MANAGER_AVAILABLE:
            raise Exception("WebDriverManager not available")
            
        try:
            chrome_binary = self._find_chrome_binary()
            if isinstance(chrome_binary, list):
                chrome_binary = chrome_binary[0]
                
            driver_path = ChromeDriverManager().install()
            
            options = ChromeOptions()
            self._configure_chrome_options(options, chrome_binary)
            
            service = ChromeService(driver_path)
            driver = webdriver.Chrome(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"WebDriverManager Chrome failed: {e}")
    
    def _try_manual_chrome_download(self):
        """Try manual Chrome driver download"""
        try:
            chrome_binary = self._find_chrome_binary()
            if not chrome_binary:
                raise Exception("Chrome binary not found")
            
            if isinstance(chrome_binary, list):
                chrome_binary = chrome_binary[0]
            
            driver_path = self._download_chromedriver_manual()
            if not driver_path:
                raise Exception("Manual download failed")
            
            options = ChromeOptions()
            self._configure_chrome_options(options, chrome_binary)
            
            service = ChromeService(driver_path)
            driver = webdriver.Chrome(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"Manual Chrome download failed: {e}")
    
    def _try_system_chrome(self):
        """Try using system Chrome driver"""
        try:
            chrome_binary = self._find_chrome_binary()
            if not chrome_binary:
                raise Exception("Chrome binary not found")
            
            if isinstance(chrome_binary, list):
                chrome_binary = chrome_binary[0]
            
            # Look for chromedriver in PATH
            driver_path = None
            try:
                result = subprocess.run(['which', 'chromedriver'], capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and result.stdout.strip():
                    driver_path = result.stdout.strip()
            except:
                pass
            
            if not driver_path:
                # Check common system locations
                system_paths = [
                    '/usr/bin/chromedriver',
                    '/usr/local/bin/chromedriver',
                    '/opt/bin/chromedriver'
                ]
                for path in system_paths:
                    if os.path.exists(path):
                        driver_path = path
                        break
            
            if not driver_path:
                raise Exception("chromedriver not found in system")
            
            options = ChromeOptions()
            self._configure_chrome_options(options, chrome_binary)
            
            service = ChromeService(driver_path)
            driver = webdriver.Chrome(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"System Chrome failed: {e}")
    
    def _try_cached_chrome(self):
        """Try using cached Chrome driver"""
        try:
            chrome_binary = self._find_chrome_binary()
            if not chrome_binary:
                raise Exception("Chrome binary not found")
            
            if isinstance(chrome_binary, list):
                chrome_binary = chrome_binary[0]
            
            # Look for cached drivers
            cached_drivers = [f for f in os.listdir(self.drivers_dir) if f.startswith('chromedriver')]
            if not cached_drivers:
                raise Exception("No cached drivers found")
            
            # Use the most recent one
            cached_drivers.sort(reverse=True)
            driver_path = os.path.join(self.drivers_dir, cached_drivers[0])
            
            if not self._check_driver_exists(driver_path):
                raise Exception("Cached driver not executable")
            
            options = ChromeOptions()
            self._configure_chrome_options(options, chrome_binary)
            
            service = ChromeService(driver_path)
            driver = webdriver.Chrome(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"Cached Chrome failed: {e}")
    
    def _try_alternative_chrome_download(self):
        """Try alternative Chrome download sources"""
        try:
            chrome_binary = self._find_chrome_binary()
            if not chrome_binary:
                raise Exception("Chrome binary not found")
            
            if isinstance(chrome_binary, list):
                chrome_binary = chrome_binary[0]
            
            # Try downloading an older stable version
            driver_path = self._download_chromedriver_manual(version="119.0.6045.105")
            if not driver_path:
                raise Exception("Alternative download failed")
            
            options = ChromeOptions()
            self._configure_chrome_options(options, chrome_binary)
            
            service = ChromeService(driver_path)
            driver = webdriver.Chrome(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"Alternative Chrome download failed: {e}")
    
    def _configure_chrome_options(self, options, chrome_binary=None):
        """Configure Chrome options with all necessary settings"""
        # Basic headless configuration
        options.add_argument('--headless=new')  # Use new headless mode
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--window-size=1920,1080')
        options.add_argument('--disable-logging')
        options.add_argument('--log-level=3')
        options.add_argument('--disable-web-security')
        options.add_argument('--disable-features=VizDisplayCompositor')
        options.add_argument('--disable-extensions')
        options.add_argument('--disable-plugins')
        options.add_argument('--disable-blink-features=AutomationControlled')
        
        # Server environment optimizations
        options.add_argument('--remote-debugging-port=0')  # Use random port
        options.add_argument('--disable-background-timer-throttling')
        options.add_argument('--disable-backgrounding-occluded-windows')
        options.add_argument('--disable-renderer-backgrounding')
        options.add_argument('--disable-features=TranslateUI')
        options.add_argument('--disable-default-apps')
        options.add_argument('--no-first-run')
        options.add_argument('--disable-background-networking')
        options.add_argument('--disable-sync')
        options.add_argument('--disable-translate')
        options.add_argument('--hide-scrollbars')
        options.add_argument('--metrics-recording-only')
        options.add_argument('--mute-audio')
        options.add_argument('--no-default-browser-check')
        options.add_argument('--no-zygote')
        options.add_argument('--disable-software-rasterizer')
        
        # Memory optimizations
        options.add_argument('--memory-pressure-off')
        options.add_argument('--max_old_space_size=4096')
        
        # Proxy configuration
        if self.proxy_config:
            options.add_argument(f'--proxy-server={self.proxy_config["url"]}')
        
        # Chrome binary path
        if chrome_binary:
            options.binary_location = chrome_binary
        
        # User agent
        options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36')
        
        # Security settings for server environments
        options.add_argument('--ignore-certificate-errors')
        options.add_argument('--ignore-ssl-errors')
        options.add_argument('--ignore-certificate-errors-spki-list')
        options.add_argument('--ignore-certificate-errors-ssl-errors')
        options.add_argument('--allow-running-insecure-content')
        options.add_argument('--disable-web-security')
        options.add_argument('--allow-cross-origin-auth-prompt')
        
        # Experimental options
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # Additional prefs for better compatibility
        prefs = {
            "profile.default_content_setting_values": {
                "notifications": 2
            },
            "profile.default_content_settings.popups": 0,
            "profile.managed_default_content_settings.images": 1
        }
        options.add_experimental_option("prefs", prefs)
    
    def get_firefox_driver_robust(self, max_attempts=5):
        """Get Firefox driver with comprehensive fallback methods"""
        attempts = []
        
        # Add WebDriverManager if available
        if WEBDRIVER_MANAGER_AVAILABLE:
            attempts.append(("WebDriverManager", self._try_webdriver_manager_firefox))
        
        # Add other methods
        attempts.extend([
            ("Manual Download", self._try_manual_firefox_download),
            ("System PATH", self._try_system_firefox),
            ("Cached Driver", self._try_cached_firefox)
        ])
        
        for attempt_num, (method_name, method) in enumerate(attempts):
            if attempt_num >= max_attempts:
                break
                
            try:
                print(f"üîÑ Tentativa {attempt_num + 1}: {method_name}")
                driver = method()
                if driver:
                    print(f"‚úÖ Firefox driver criado via: {method_name}")
                    return driver
            except Exception as e:
                print(f"‚ö†Ô∏è {method_name} falhou: {str(e)}")
                continue
        
        print("‚ùå Todas as tentativas de Firefox falharam")
        return None
    
    def _try_webdriver_manager_firefox(self):
        """Try using WebDriverManager for Firefox"""
        if not WEBDRIVER_MANAGER_AVAILABLE:
            raise Exception("WebDriverManager not available")
            
        try:
            firefox_binary = self._find_firefox_binary()
            if isinstance(firefox_binary, list):
                firefox_binary = firefox_binary[0]
                
            driver_path = GeckoDriverManager().install()
            
            options = FirefoxOptions()
            self._configure_firefox_options(options, firefox_binary)
            
            service = FirefoxService(driver_path)
            driver = webdriver.Firefox(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"WebDriverManager Firefox failed: {e}")
    
    def _try_manual_firefox_download(self):
        """Try manual Firefox driver download"""
        try:
            firefox_binary = self._find_firefox_binary()
            if not firefox_binary:
                raise Exception("Firefox binary not found")
            
            if isinstance(firefox_binary, list):
                firefox_binary = firefox_binary[0]
            
            driver_path = self._download_geckodriver_manual()
            if not driver_path:
                raise Exception("Manual download failed")
            
            options = FirefoxOptions()
            self._configure_firefox_options(options, firefox_binary)
            
            service = FirefoxService(driver_path)
            driver = webdriver.Firefox(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"Manual Firefox download failed: {e}")
    
    def _try_system_firefox(self):
        """Try using system Firefox driver"""
        try:
            firefox_binary = self._find_firefox_binary()
            if not firefox_binary:
                raise Exception("Firefox binary not found")
            
            if isinstance(firefox_binary, list):
                firefox_binary = firefox_binary[0]
            
            # Look for geckodriver in PATH
            driver_path = None
            try:
                result = subprocess.run(['which', 'geckodriver'], capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and result.stdout.strip():
                    driver_path = result.stdout.strip()
            except:
                pass
            
            if not driver_path:
                # Check common system locations
                system_paths = [
                    '/usr/bin/geckodriver',
                    '/usr/local/bin/geckodriver',
                    '/opt/bin/geckodriver'
                ]
                for path in system_paths:
                    if os.path.exists(path):
                        driver_path = path
                        break
            
            if not driver_path:
                raise Exception("geckodriver not found in system")
            
            options = FirefoxOptions()
            self._configure_firefox_options(options, firefox_binary)
            
            service = FirefoxService(driver_path)
            driver = webdriver.Firefox(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"System Firefox failed: {e}")
    
    def _try_cached_firefox(self):
        """Try using cached Firefox driver"""
        try:
            firefox_binary = self._find_firefox_binary()
            if not firefox_binary:
                raise Exception("Firefox binary not found")
            
            if isinstance(firefox_binary, list):
                firefox_binary = firefox_binary[0]
            
            # Look for cached drivers
            cached_drivers = [f for f in os.listdir(self.drivers_dir) if f.startswith('geckodriver')]
            if not cached_drivers:
                raise Exception("No cached drivers found")
            
            # Use the most recent one
            cached_drivers.sort(reverse=True)
            driver_path = os.path.join(self.drivers_dir, cached_drivers[0])
            
            if not self._check_driver_exists(driver_path):
                raise Exception("Cached driver not executable")
            
            options = FirefoxOptions()
            self._configure_firefox_options(options, firefox_binary)
            
            service = FirefoxService(driver_path)
            driver = webdriver.Firefox(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"Cached Firefox failed: {e}")
    
    def _configure_firefox_options(self, options, firefox_binary=None):
        """Configure Firefox options with all necessary settings"""
        # Basic headless configuration
        options.add_argument("--headless")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--width=1920")
        options.add_argument("--height=1080")
        
        # Firefox binary path
        if firefox_binary:
            options.binary_location = firefox_binary
        
        # Proxy configuration
        if self.proxy_config:
            options.set_preference("network.proxy.type", 1)
            options.set_preference("network.proxy.http", self.proxy_config['host'])
            options.set_preference("network.proxy.http_port", self.proxy_config['port'])
            options.set_preference("network.proxy.ssl", self.proxy_config['host'])
            options.set_preference("network.proxy.ssl_port", self.proxy_config['port'])
            options.set_preference("network.proxy.share_proxy_settings", True)
            options.set_preference("network.proxy.autoconfig_url", "")
        
        # Basic preferences
        options.set_preference("javascript.enabled", True)
        options.set_preference("dom.webdriver.enabled", False)
        options.set_preference('useAutomationExtension', False)
        options.set_preference("dom.ipc.plugins.enabled.libflashplayer.so", False)
        
        # User agent
        options.set_preference("general.useragent.override", 
                             "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:119.0) Gecko/20100101 Firefox/119.0")
        
        # Performance and security settings
        options.set_preference("network.http.connection-timeout", 60)
        options.set_preference("network.http.response.timeout", 60)
        options.set_preference("security.tls.insecure_fallback_hosts", "")
        options.set_preference("security.tls.skip_pki_certificate_verification", True)
        
        # Memory optimizations
        options.set_preference("browser.cache.disk.enable", False)
        options.set_preference("browser.cache.memory.enable", False)
        options.set_preference("browser.cache.offline.enable", False)
        options.set_preference("network.http.use-cache", False)
        
        # Disable unnecessary features
        options.set_preference("media.autoplay.enabled", False)
        options.set_preference("dom.push.enabled", False)
        options.set_preference("dom.webnotifications.enabled", False)
        options.set_preference("geo.enabled", False)
    
    def get_edge_driver_robust(self, max_attempts=3):
        """Get Edge driver with fallback methods"""
        attempts = []
        
        # Add WebDriverManager if available
        if WEBDRIVER_MANAGER_AVAILABLE:
            attempts.append(("WebDriverManager", self._try_webdriver_manager_edge))
        
        attempts.append(("System PATH", self._try_system_edge))
        
        for attempt_num, (method_name, method) in enumerate(attempts):
            if attempt_num >= max_attempts:
                break
                
            try:
                print(f"üîÑ Tentativa {attempt_num + 1}: {method_name}")
                driver = method()
                if driver:
                    print(f"‚úÖ Edge driver criado via: {method_name}")
                    return driver
            except Exception as e:
                print(f"‚ö†Ô∏è {method_name} falhou: {str(e)}")
                continue
        
        print("‚ùå Todas as tentativas de Edge falharam")
        return None
    
    def _try_webdriver_manager_edge(self):
        """Try using WebDriverManager for Edge"""
        if not WEBDRIVER_MANAGER_AVAILABLE:
            raise Exception("WebDriverManager not available")
            
        try:
            driver_path = EdgeChromiumDriverManager().install()
            
            options = EdgeOptions()
            self._configure_edge_options(options)
            
            service = EdgeService(driver_path)
            driver = webdriver.Edge(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"WebDriverManager Edge failed: {e}")
    
    def _try_system_edge(self):
        """Try using system Edge driver"""
        try:
            # Look for msedgedriver in PATH
            driver_path = None
            try:
                result = subprocess.run(['which', 'msedgedriver'], capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and result.stdout.strip():
                    driver_path = result.stdout.strip()
            except:
                pass
            
            if not driver_path:
                raise Exception("msedgedriver not found in system PATH")
            
            options = EdgeOptions()
            self._configure_edge_options(options)
            
            service = EdgeService(driver_path)
            driver = webdriver.Edge(service=service, options=options)
            
            return self._test_driver(driver)
        except Exception as e:
            raise Exception(f"System Edge failed: {e}")
    
    def _configure_edge_options(self, options):
        """Configure Edge options with all necessary settings"""
        # Basic headless configuration
        options.add_argument('--headless=new')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--window-size=1920,1080')
        options.add_argument('--disable-logging')
        options.add_argument('--log-level=3')
        options.add_argument('--disable-web-security')
        options.add_argument('--disable-features=VizDisplayCompositor')
        options.add_argument('--disable-extensions')
        options.add_argument('--disable-plugins')
        options.add_argument('--disable-blink-features=AutomationControlled')
        
        # Proxy configuration
        if self.proxy_config:
            options.add_argument(f'--proxy-server={self.proxy_config["url"]}')
        
        # User agent
        options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0')
        
        # Additional options similar to Chrome
        options.add_argument('--disable-background-timer-throttling')
        options.add_argument('--disable-backgrounding-occluded-windows')
        options.add_argument('--disable-renderer-backgrounding')
        options.add_argument('--disable-features=TranslateUI')
        options.add_argument('--disable-default-apps')
        options.add_argument('--no-first-run')
        
        # Experimental options
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
    
    def _test_driver(self, driver):
        """Test if driver is working properly"""
        try:
            # Set timeouts
            driver.set_page_load_timeout(45)
            driver.implicitly_wait(15)
            
            # Test basic functionality
            driver.get("data:text/html,<html><body><h1>Test</h1></body></html>")
            
            # Execute a simple script to verify JavaScript works
            result = driver.execute_script("return 'test'")
            if result != 'test':
                raise Exception("JavaScript execution failed")
            
            # Hide automation indicators
            driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            
            print(f"‚úÖ Driver testado com sucesso")
            return driver
            
        except Exception as e:
            try:
                driver.quit()
            except:
                pass
            raise Exception(f"Driver test failed: {e}")
    
    def get_driver_with_all_fallbacks(self):
        """Try all available browsers with full fallback chain"""
        browsers = [
            ("Chrome", self.get_chrome_driver_robust),
            ("Firefox", self.get_firefox_driver_robust),
            ("Edge", self.get_edge_driver_robust)
        ]
        
        for browser_name, method in browsers:
            try:
                print(f"üåê Tentando {browser_name}...")
                driver = method()
                if driver:
                    print(f"üéâ Sucesso com {browser_name}!")
                    return driver
            except Exception as e:
                print(f"‚ùå {browser_name} falhou completamente: {e}")
                continue
        
        raise Exception("‚ùå ERRO CR√çTICO: Nenhum browser dispon√≠vel!")
    
    def install_system_dependencies(self):
        """Try to install missing system dependencies"""
        print("üîß Tentando instalar depend√™ncias do sistema...")
        
        if self.system_info['distro'] == 'ubuntu' or self.system_info['distro'] == 'debian':
            commands = [
                "sudo apt update",
                "sudo apt install -y wget curl unzip",
                "wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -",
                "echo 'deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main' | sudo tee /etc/apt/sources.list.d/google-chrome.list",
                "sudo apt update",
                "sudo apt install -y google-chrome-stable firefox-esr"
            ]
        elif self.system_info['distro'] == 'rhel':
            commands = [
                "sudo yum update -y",
                "sudo yum install -y wget curl unzip",
                "wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo rpm --import -",
                "sudo yum install -y google-chrome-stable firefox"
            ]
        elif self.system_info['distro'] == 'alpine':
            commands = [
                "sudo apk update",
                "sudo apk add --no-cache chromium firefox wget curl unzip"
            ]
        else:
            print("‚ö†Ô∏è Distribui√ß√£o n√£o suportada para instala√ß√£o autom√°tica")
            return False
        
        for cmd in commands:
            try:
                print(f"  Executando: {cmd}")
                result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=60)
                if result.returncode != 0:
                    print(f"  ‚ö†Ô∏è Comando falhou: {cmd}")
            except Exception as e:
                print(f"  ‚ùå Erro executando comando: {e}")
        
        print("‚úÖ Instala√ß√£o de depend√™ncias conclu√≠da")
        return True
    
    def cleanup(self):
        """Clean up temporary files"""
        try:
            if os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir)
        except:
            pass

# Initialize global driver manager
driver_manager = RobustDriverManager()

# ============================================================================
# UPDATED DRIVER FUNCTIONS (using the robust manager)
# ============================================================================

def get_driver_with_proxy():
    """Get a webdriver with proxy support using robust manager"""
    return driver_manager.get_driver_with_all_fallbacks()

def get_initial_cookies(max_retries=4, retry_delay=2):
    """Get initial cookies and token from OAB website with retry logic"""
    for attempt in range(max_retries):
        driver = None
        try:
            print(f"    üç™ Tentativa {attempt + 1} de obter cookies...")
            driver = get_driver_with_proxy()
            driver.get("https://cna.oab.org.br/")
            
            # Wait for page to load completely
            WebDriverWait(driver, 20).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            time.sleep(3)

            cookies = driver.get_cookies()
            cookie_dict = {cookie['name']: cookie['value'] for cookie in cookies}

            # More robust token finding
            try:
                token_element = WebDriverWait(driver, 20).until(
                    EC.presence_of_element_located((By.NAME, "__RequestVerificationToken"))
                )
                token = token_element.get_attribute("value")
            except TimeoutException:
                # Fallback: try to find token in page source
                page_source = driver.page_source
                soup = BeautifulSoup(page_source, 'html.parser')
                token_input = soup.find('input', {'name': '__RequestVerificationToken'})
                if token_input and token_input.get('value'):
                    token = token_input.get('value')
                else:
                    raise Exception("Could not find verification token")

            print(f"    ‚úÖ Cookies e token obtidos com sucesso!")
            return cookie_dict, token
            
        except Exception as e:
            print(f"    ‚ö†Ô∏è Tentativa {attempt + 1} falhou: {str(e)}")
            if attempt < max_retries - 1:
                print(f"    ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                time.sleep(retry_delay)
            else:
                raise Exception(f"Failed to get initial cookies after {max_retries} attempts: {str(e)}")
        finally:
            if driver:
                try:
                    driver.quit()
                except:
                    pass

def get_modal_data_with_selenium(url, max_wait=30, max_retries=4, retry_delay=2):
    """Get modal data from sociedade URL using Selenium with retry logic"""
    for attempt in range(max_retries):
        driver = None
        try:
            print(f"        üåê Tentativa {attempt + 1}: Navegando para: {url}")
            driver = get_driver_with_proxy()
            driver.get(url)

            # Wait specifically for the modal content to appear
            print(f"        ‚è≥ Aguardando modal aparecer...")
            wait = WebDriverWait(driver, max_wait)
            modal = wait.until(
                EC.visibility_of_element_located((By.CLASS_NAME, "modal-content"))
            )

            # Additional wait for content to load completely
            time.sleep(3)

            # Get the complete modal HTML
            print(f"        üìã Extraindo dados do modal...")
            modal_html = modal.get_attribute('outerHTML')
            
            # Extract structured data using the specific parser
            modal_data = extract_modal_data(modal_html)
            
            if modal_data:
                print(f"        ‚úÖ Modal extra√≠do com sucesso:")
                print(f"             - Firma: {modal_data.get('firm_name', 'N/A')}")
                print(f"             - Inscri√ß√£o: {modal_data.get('inscricao', 'N/A')}")
                print(f"             - Estado: {modal_data.get('estado', 'N/A')}")
                print(f"             - S√≥cios: {len(modal_data.get('socios', []))}")
                
                # Return structured data with metadata
                return {
                    'extraction_method': 'specific_modal_parser',
                    'content_loaded': True,
                    'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                    'url': url,
                    'modal_data': modal_data,
                    'extraction_success': 5 if modal_data.get('firm_name') else 3
                }
            else:
                print(f"        ‚ùå Falha na extra√ß√£o dos dados do modal")
                if attempt < max_retries - 1:
                    print(f"        ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                    time.sleep(retry_delay)
                    continue
                
                return {
                    'extraction_method': 'specific_modal_parser',
                    'content_loaded': False,
                    'error': 'Failed to extract modal data after all retries',
                    'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                    'url': url,
                    'extraction_success': 0
                }

        except TimeoutException:
            error_msg = f"Timeout waiting for modal to appear at {url}"
            print(f"        ‚è∞ Tentativa {attempt + 1}: Modal n√£o apareceu em {max_wait}s")
            
            if attempt < max_retries - 1:
                print(f"        ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                time.sleep(retry_delay)
                continue
            
            return {
                'extraction_method': 'specific_modal_parser',
                'content_loaded': False,
                'error': error_msg,
                'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                'url': url,
                'extraction_success': 0
            }
        except Exception as e:
            error_msg = f"Error getting modal data from {url}: {str(e)}"
            logger.error(error_msg)
            print(f"        ‚ùå Tentativa {attempt + 1}: Erro geral: {str(e)}")
            
            if attempt < max_retries - 1:
                print(f"        ‚è≥ Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                time.sleep(retry_delay)
                continue
            
            return {
                'extraction_method': 'specific_modal_parser',
                'content_loaded': False,
                'error': str(e),
                'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                'url': url,
                'extraction_success': 0
            }
        finally:
            if driver:
                try:
                    driver.quit()
                except:
                    pass

# ============================================================================
# UTILITY FUNCTIONS (keeping existing ones)
# ============================================================================

def upload_to_s3(data, key, content_type='application/json'):
    """Upload data to S3 bucket"""
    try:
        if isinstance(data, (dict, list)):
            # Convert dict/list to JSON string
            content = json.dumps(data, ensure_ascii=False, indent=2)
        else:
            content = str(data)
        
        s3_client.put_object(
            Bucket=AWS_BUCKET,
            Key=key,
            Body=content.encode('utf-8'),
            ContentType=content_type,
            ServerSideEncryption='AES256'
        )
        return f"s3://{AWS_BUCKET}/{key}"
    except Exception as e:
        print(f"‚ùå Erro ao fazer upload para S3: {e}")
        return None

def upload_file_to_s3(local_file_path, s3_key):
    """Upload local file to S3"""
    try:
        s3_client.upload_file(
            local_file_path, 
            AWS_BUCKET, 
            s3_key,
            ExtraArgs={'ServerSideEncryption': 'AES256'}
        )
        return f"s3://{AWS_BUCKET}/{s3_key}"
    except Exception as e:
        print(f"‚ùå Erro ao fazer upload do arquivo para S3: {e}")
        return None

def save_to_s3_and_local_backup(data, filename, content_type='application/json'):
    """Save data to S3 and keep local backup for emergency"""
    try:
        # Save to S3
        s3_key = f"oab_data/{filename}"
        s3_url = upload_to_s3(data, s3_key, content_type)
        
        if s3_url:
            print(f"  ‚úÖ Salvo no S3: {s3_url}")
            
            # Create local backup (small file for emergency recovery)
            try:
                with open(filename, 'w', encoding='utf-8') as f:
                    if isinstance(data, (dict, list)):
                        json.dump(data, f, indent=2, ensure_ascii=False)
                    else:
                        f.write(str(data))
                print(f"  üìÅ Backup local: {filename}")
            except Exception as e:
                print(f"  ‚ö†Ô∏è Backup local falhou: {e}")
            
            return s3_url
        else:
            # Fallback to local only
            print(f"  ‚ö†Ô∏è S3 falhou, salvando apenas localmente")
            with open(filename, 'w', encoding='utf-8') as f:
                if isinstance(data, (dict, list)):
                    json.dump(data, f, indent=2, ensure_ascii=False)
                else:
                    f.write(str(data))
            return filename
            
    except Exception as e:
        print(f"  ‚ùå Erro no salvamento: {e}")
        # Emergency local save
        try:
            with open(f"emergency_{filename}", 'w', encoding='utf-8') as f:
                if isinstance(data, (dict, list)):
                    json.dump(data, f, indent=2, ensure_ascii=False)
                else:
                    f.write(str(data))
            return f"emergency_{filename}"
        except:
            return None

def signal_handler(signum, frame):
    """Handle Ctrl+C interruption and save current progress"""
    print("\n\nüõë INTERRUP√á√ÉO DETECTADA!")
    print("üíæ Salvando progresso atual...")
    
    if enhanced_lawyers:
        emergency_filename = save_enhanced_lawyers_to_file(
            enhanced_lawyers, 
            current_batch_file, 
            emergency=True
        )
        print(f"‚úÖ Dados salvos em: {emergency_filename}")
        print(f"üìä Total processado: {len(enhanced_lawyers)} advogados")
    else:
        print("‚ö†Ô∏è Nenhum dado para salvar")
    
    if error_log:
        batch_base = os.path.splitext(os.path.basename(current_batch_file))[0] if current_batch_file else "unknown"
        error_file_name = f"error_log_{batch_base}_emergency_{time.strftime('%Y%m%d_%H%M%S')}.txt"
        save_to_s3_and_local_backup(
            "\n".join([f"Log de Erros de Emerg√™ncia - {current_batch_file}", "="*50, ""] + error_log),
            error_file_name,
            'text/plain'
        )
        print(f"üìù Log de erros salvo: {error_file_name}")
    
    # Cleanup driver manager
    try:
        driver_manager.cleanup()
    except:
        pass